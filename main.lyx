#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass acmart
\begin_preamble
\usepackage{pgfplots}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{url}
%\usepackage{minted}


%\DeclareUnicodeCharacter{2212}{âˆ’}
\usepgfplotslibrary{groupplots,dateplot}
\usetikzlibrary{
    patterns,
    chains,
    backgrounds,
    calc,
    shadings,
    shapes.arrows,
    arrows,
    shapes.symbols,
    shadows,
    positioning,
    decorations.markings,
    backgrounds,
    arrows.meta,
    external
}
\usepackage{array}


\pgfplotsset{compat=newest}

\newcommand{\code}[1]{\texttt{#1}}

\newif\iffinal

\iffinal
  \newcommand{\maxx}[1]{}
  \newcommand{\ryan}[1]{}
  \newcommand{\todo}[1]{}
\else
  \newcommand{\maxx}[1]{{\textcolor{red}{ Max: #1 }}}
  \newcommand{\ryan}[1]{{\textcolor{magenta}{ Ryan: #1 }}}
  \newcommand{\todo}[1]{{\textcolor{blue}{ TODO: #1 }}}
\fi
\end_preamble
\options sigconf,nonacm
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding utf8
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 2
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Ultrafast focus detection using multi-scale histologic features
\end_layout

\begin_layout Author
Maksim Levental
\end_layout

\begin_layout Affiliation
\begin_inset Flex Institution
status collapsed

\begin_layout Plain Layout
University of Chicago
\end_layout

\end_inset


\end_layout

\begin_layout Author
Ryan Chard
\end_layout

\begin_layout Affiliation
\begin_inset Flex Institution
status collapsed

\begin_layout Plain Layout
Argonne National Laboratory
\end_layout

\end_inset


\end_layout

\begin_layout Author
Gregg A.
 Wildenberg
\end_layout

\begin_layout Affiliation
\begin_inset Flex Institution
status collapsed

\begin_layout Plain Layout
University of Chicago
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We present a fast out-of-focus detection algorithm for electron microscopy
 images collected serially.
 Such images are collected for the purposes of post-processing tasks such
 as montaging, alignment, and image segmentation.
 Such an algorithm is necessitated by recent increases in collection rates
 owing to advances in microscopy technology.
 Our technique adapts classical computer vision and is based on detecting
 various fine-grained histologic features.
 We further exploit the inherent parallelism in the technique by employing
 GPGPU primitives in order to accelerate characterization.
 Tests are performed that demonstrate faster than real time detection of
 out-of-focus conditions.
 <We also deploy to funcX something something>.
 We discuss extensions that enable scaling out to support multi-beam microscopes
 and integration with existing focus systems for purposes of implementing
 auto-focus.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:intro"

\end_inset


\end_layout

\begin_layout Standard
Advancements in the automation of serial scanning electron microscopy (SEM)
 impose a regime where thousands, if not tens of thousands, of images can
 now be automatically collected by researchers.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
todo{
\end_layout

\end_inset

<bio use cases>
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 This puts greater demand on conventional auto-focus algorithms for ensuring
 each image is in focus, as an alternative to the user manually evaluating
 each image by eye.
 Without such algorithms, critical bottlenecks are created where the user
 is forced to reacquire individual, deficient (out-of-focus), images and
 manually reinsert them into the sequence of thousands of other images already
 acquired.
 This is an onerous task which requires taking into account alignment and
 boundary overlap.
 Furthermore, failure to quickly identify and reacquire deficient images
 negatively impacts the accuracy of downstream, post-processing; for example
 2D montaging, 3D alignment, or automatic segmentation pipelines.
 While many microscopes have builtin auto-focus algorithms, these often
 fail to achieve acceptable accuracy due to intrinsic mediating factors
 (e.g.
 stage drift) and extrinsic mediating factors (e.g.
 sample artifacts, non-uniformity in the sample).
\end_layout

\begin_layout Standard
Auto-focus technology is a critical component of many imaging systems; from
 consumer cameras (for purposes of convenience) to industrial inspection
 tools to scientific instrumentation.
 Such technology is typically either active or passive; active methods exploit
 some auxiliary device or mechanism to measure the distance of the optics
 from the scene, while passive methods analyze the definition of sharpness
 of an image by virtue of some proxy measure.
 Here we focus on passive methods, as we explicitly aim to augment existing
 microscopy equipment without the need for costly and complex retrofitting.
\end_layout

\begin_layout Standard
Passive proxies for the degree-of-focus (DOF) include the energy of the
 Laplacian, discrete cosine transform, or weighted histogram of an image;
 for effecting a high DOF a search can be performed.
 When used as a component of an auto-focus system (as opposed to OOF detection
 system) all such passive methods are unsuitable for the purpose of real-time
 (or even near-real-time) characterization of DOF due to their long scanning
 times (multiple images need to be collected at potentially different depths).
 As our method currently aims only to detect OOF events we do not consider
 or implement any focus search techniques (but do describe plans for such
 future work).
\end_layout

\begin_layout Standard
To overcome these challenges, thereby ensuring that images are faithfully
 acquired, we propose a method to evaluate image definition based multi-scale
 histologic feature detection (MHFD).
 By multi-scale histologic feature detection we mean the resolving and character
ization of histological structure at multiple length scales; for our particular
 use-case this means structures ranging from cell walls to whole organelles.
 The key insight being that the ability to resolve structure across the
 range of feature scales is highly correlated with a high-definition, i.e.
 in-focus, image.
\end_layout

\begin_layout Standard
Due to limitations of the extensibility of commercial microscopy equipment,
 we do not aim here to directly implement auto-focusing.
 Rather than focusing the microscope, as auto-focusing algorithms would,
 our algorithm operates downstream of collection and reports out-of-focus
 (OOF) events to the user.
 This enables the user to intervene and initiate reacquisition protocols
 (on the microscope) before unknowingly proceeding with collecting the next
 series of images or proceeding with downstream image processing and analysis.
 This human-in-the-loop remediation protocol already saves the user much
 wasted collection time and tedium in triaging defective collection runs.
\end_layout

\begin_layout Standard
This rest of this article is organized as follows: section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:mhd"
plural "false"
caps "false"
noprefix "false"

\end_inset

 describes our focus detection method in the abstract, section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:implementation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 discusses optimizations made in order to achieve real-time performance
 with our method, section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Evaluation"
plural "false"
caps "false"
noprefix "false"

\end_inset

 reports results of evaluating our method on sequences of images collected
 at varying focus depths, section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:related"
plural "false"
caps "false"
noprefix "false"

\end_inset

 discusses related work and how our work is distinct therefrom, and finally
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:conclusion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 concludes with a discussion of future research.
\end_layout

\begin_layout Section
Gregg sells science!
\end_layout

\begin_layout Standard
TYPE HERE
\end_layout

\begin_layout Section
Multi-scale Histologic Feature Detection
\begin_inset CommandInset label
LatexCommand label
name "sec:mhd"

\end_inset


\end_layout

\begin_layout Subsection
Scale-space
\end_layout

\begin_layout Standard
We base our multi-scale histologic feature detection on classic scale-space
 representations of signals.
 We give a brief overview (a more comprehensive discussion is available
 
\begin_inset CommandInset citation
LatexCommand citet
key "Lindeberg2004FeatureDW"
literal "false"

\end_inset

) and describe our adaptation.
\end_layout

\begin_layout Standard
The fundamental principle of scale-space feature detection is that natural
 images possess structure at multiple scales and that features at a particular
 scale can be characterized in isolation of features at other scales.
 Typically, characterization is effected by convolution with a filter that
 satisfies the constraints of non-enhancement of local extrema, scale invariance
 and rotational invariance (along with some others 
\begin_inset CommandInset citation
LatexCommand citet
key "duits2004axioms"
literal "false"

\end_inset

).
 One such filter 
\begin_inset CommandInset citation
LatexCommand citet
key "koenderink1984structure"
literal "false"

\end_inset

 is the symmetric, mean zero, two dimensional, Gaussian filter 
\begin_inset Formula 
\[
G(x,y,\sigma)\coloneqq\frac{1}{2\pi\sigma^{2}}e^{-\frac{x^{2}+y^{2}}{2\sigma^{2}}}
\]

\end_inset

Thus, define the scale-space representation 
\begin_inset Formula $L(x,y,t)$
\end_inset

 of an image 
\begin_inset Formula $I(x,y)$
\end_inset

 to be the convolution of that image with a mean zero Gaussian filter: 
\begin_inset Formula 
\[
L(x,y,t)\coloneqq G(x,y,t)*I(x,y)
\]

\end_inset

where 
\begin_inset Formula $t$
\end_inset

 determines the 
\shape italic
scale
\shape default
 of 
\begin_inset Formula $L(x,y,t)$
\end_inset

.
 
\begin_inset Formula $L(x,y,t)$
\end_inset

 has the interpretation that image structures of scale smaller than 
\begin_inset Formula $\sqrt{t^{2}}=t$
\end_inset

 have been removed due to blurring.
 This is due to the fact that the variance of the Gaussian filter is 
\begin_inset Formula $t^{2}$
\end_inset

 and features of this scale are therefore 
\begin_inset Quotes eld
\end_inset

beneath the noise floor
\begin_inset Quotes erd
\end_inset

 of the filter or, in effect, suppressed by filtering procedure.
 A corollary is that features with approximate length scale 
\begin_inset Formula $t$
\end_inset

 will have maximal response upon being filtered by 
\begin_inset Formula $G(x,y,t)$
\end_inset

; for 
\begin_inset Formula $t'<t$
\end_inset

 smaller length scale features will dominate the response and for 
\begin_inset Formula $t''>t$
\end_inset

, as already mentioned, the response will have been suppressed.
 Hence, at various scales we can use linear and non-linear combinations
 of space derivatives 
\begin_inset Formula $\partial_{x},\partial_{y}$
\end_inset

 and derivatives in scale 
\begin_inset Formula $\partial_{t}$
\end_inset

 to construct scale-invariant feature detectors; such feature detectors
 detect features such as corners, edges, and ridges.
 For example, the critical points in 
\begin_inset Formula $t$
\end_inset

 
\begin_inset Formula 
\begin{equation}
\partial_{t}\nabla^{2}L\coloneqq\partial_{t}\left(\partial_{x}^{2}+\partial_{y}^{2}\right)L\label{eqn:blobdetector}
\end{equation}

\end_inset

correspond to uniform region (otherwise known as blobs) detectors.
\end_layout

\begin_layout Subsection
Multi-scale Histologic Feature Detection
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:implementation"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{subfigure}[b]
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

0.5
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textwidth
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Graphics
	filename in_focus.png
	lyxscale 50
	width 100line%

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Histologic features of an in-focus section.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:infocus"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{subfigure}[b]
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

0.5
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textwidth
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Graphics
	filename out_of_focus.png
	lyxscale 50
	width 100line%

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Histologic features of an out-of-focus section.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:outoffocus"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparison of sections with histologic feature recognition as a function
 of focal depth.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:histfeatsimages"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We propose to use feature detection as a proxy for DOF, reasoning that the
 quantity of features detected is positively correlated with DOF (see figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:histfeatsimages"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 To this end, we develop a feature detector based on eqn.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:blobdetector"
plural "false"
caps "false"
noprefix "false"

\end_inset

 but optimized for latency (rather than for accuracy).
 In order to verify our hypothesis we compare the number of histologic features
 detected as a function of absolute deviation from in-focus (
\begin_inset Formula $\lvert f-f'\rvert$
\end_inset

 where 
\begin_inset Formula $f'$
\end_inset

 is the correct focal depth) for a series of sections with known focal depth
 (see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:degreeoofcurve"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We observe a very strong log-linear relationship (see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:degreeooffit"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Fitting such a log-linear relationship produces a line with 
\begin_inset Formula $r=-0.9754$
\end_inset

, confirming our hypothesis that quantity of histologic features detected
 is a good proxy measure for DOF.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{subfigure}[b]
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

0.5
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textwidth
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset CommandInset include
LatexCommand input
preview true
filename "blob_count_curve.tex"

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Number of histologic features as a function of absolute deviation from focused
 (
\begin_inset Formula $\lvert f-f'\rvert$
\end_inset

 where 
\begin_inset Formula $f'$
\end_inset

 is the correct focal depth).
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:degreeoofcurve"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{subfigure}[b]
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

0.5
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textwidth
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset CommandInset include
LatexCommand input
preview true
filename "blob_count_fit.tex"

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Log plot and line fit with 
\begin_inset Formula $r=-0.9754$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:degreeooffit"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparison of histologic feature recognition as a function of focal depth.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:histfeats"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We now discuss our implementation
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/makslevental/cuda_blob/"
literal "false"

\end_inset


\end_layout

\end_inset

 of the feature detector, with particular attention paid to optimizations
 in consideration of inference latency.
 Eqn.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:blobdetector"
plural "false"
caps "false"
noprefix "false"

\end_inset

 permits a discretization
\begin_inset Foot
status open

\begin_layout Plain Layout
By virtue of 
\begin_inset Formula $G$
\end_inset

 being the Green's function of the heat equation 
\begin_inset Formula $t\nabla^{2}G=\partial_{t}G$
\end_inset

.
\end_layout

\end_inset

 called 
\shape italic
Difference of Gaussians
\shape default
 (DoG) (see
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citet
key "marr1980theory"
literal "false"

\end_inset

) 
\begin_inset Formula 
\[
t^{2}\nabla^{2}L\approx t\times\left(L(x,y,t+\delta t)-L(x,y,t)\right)
\]

\end_inset

Therefore, define 
\end_layout

\begin_layout Itemize
\begin_inset Formula $n$
\end_inset

, which determines the quantity of scales determined 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\min_{t}$
\end_inset

, the minimum scale detected 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\max_{t}$
\end_inset

, the maximum scale detected 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta t\coloneqq(\max_{t}-\min_{t})/n$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{i}\coloneqq\min_{t}+(i-1)\times\delta t$
\end_inset

, the discrete scales detected 
\end_layout

\begin_layout Standard
and finally the discretized DoG 
\begin_inset Formula 
\begin{equation}
\operatorname{DoG}(x,y,i)\coloneqq t_{i}\times\left(L(x,y,t_{i+1})-L(x,y,t_{i})\right)\label{eqn:dog}
\end{equation}

\end_inset

This produces a sequence 
\begin_inset Formula $\{\operatorname{DoG}(x,y,i)\}$
\end_inset

 of filtered and scaled images (called a Gaussian pyramid 
\begin_inset CommandInset citation
LatexCommand citet
key "derpanis2005gaussian"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
Computing maxima of 
\begin_inset Formula $\operatorname{DoG}(x,y,i)$
\end_inset

 in the scale dimension (equivalently zeros of eqn.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:blobdetector"
plural "false"
caps "false"
noprefix "false"

\end_inset

) necessarily entails computing local
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In a small pixel neighborhood in both space and scale dimensions.
\end_layout

\end_inset

 maxima at every scale.
 We make the heuristic assumption that at each pixel there is a single unique,
 maximal, response at some scale; this response corresponds to the scale
 at which the variance of the Gaussian filter 
\begin_inset Formula $G$
\end_inset

 most closely corresponds to the scale of the feature.
 We therefore search for local maxima in 
\begin_inset Formula $x,y$
\end_inset

 but 
\shape italic
global
\shape default
 maxima in the scale dimension 
\begin_inset Formula 
\begin{equation}
\{(\hat{x}_{j},\hat{y}_{j},\hat{i}_{j})\}\coloneqq\operatorname*{argmaxlocal}_{x,y}\operatorname*{argmax}_{i}\operatorname{DoG}(x,y,i)\label{eqn:argmax}
\end{equation}

\end_inset

where the subscript 
\begin_inset Formula $j$
\end_inset

 indexes over the features detected.
\end_layout

\begin_layout Standard
It is readily apparent that our histologic feature detector is parallelizable;
 for each scale 
\begin_inset Formula $i$
\end_inset

 we can compute 
\begin_inset Formula $L(x,y,t_{i})$
\end_inset

 independently.
 A further parallelization is possible for the 
\begin_inset Formula $\operatorname*{argmax}$
\end_inset

 operation, since the maximum is computed independently across neighborhoods
 of pixels.
 In order to maximally exploit this we first perform the inner 
\begin_inset Formula $\operatorname*{argmax}$
\end_inset

 in eqn.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:argmax"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and then the outer.
 Note that the implementation of the inner 
\begin_inset Formula $\operatorname*{argmax}$
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

, since the 
\begin_inset Formula $\operatorname*{argmax}$
\end_inset

 primitive is implemented in exactly this way in most GPGPU libraries 
\begin_inset CommandInset citation
LatexCommand citet
key "CUB"
literal "false"

\end_inset

.
 The outer 
\begin_inset Formula $\operatorname*{argmaxlocal}$
\end_inset

 is implemented using a 
\begin_inset Formula $\operatorname{MaxPool2D}(n,n)$
\end_inset

 (with 
\begin_inset Formula $n=3$
\end_inset

).
 Employing 
\begin_inset Formula $\operatorname{MaxPool2D}$
\end_inset

 in this way has the added benefit of effectively performing non-maximum
 suppression, since it effectively rejects spurrious candidate maxima within
 a 
\begin_inset Formula $3\times3$
\end_inset

 neighborhood of a true maximum.
\end_layout

\begin_layout Standard
Typically one would compute 
\begin_inset Formula $L(x,y,t_{i})$
\end_inset

 in the naive way (by convolving 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $I$
\end_inset

) but prior work has shown 
\begin_inset CommandInset citation
LatexCommand citet
key "9307788"
literal "false"

\end_inset

 that performing the convolution in the Fourier domain is much more efficient;
 namely 
\begin_inset Formula 
\[
L(x,y,t_{i})=\mathcal{F}^{-1}\big\{\mathcal{F}\{G(x,y,t_{i})\}\cdot\mathcal{F}\{I(x,y)\}\big\}
\]

\end_inset

where 
\begin_inset Formula $\mathcal{F}\left\{ \cdot\right\} ,\mathcal{F}^{-1}\left\{ \cdot\right\} $
\end_inset

 are the Fourier transform and inverse Fourier transform, respectively.
 This approach has the additional advantage that we can make use of highly
 optimized Fast Fourier Transform (FFT) routines made available by GPGPU
 libraries.
 In particular, we can take advantage of 
\shape italic
distributed
\shape default
 FFT routines; by partitioning the set of Gaussian filters 
\begin_inset Formula $\{G(x,y,t_{i})\}$
\end_inset

 across 
\begin_inset Formula $m$
\end_inset

 nodes we can, in principle, reap a linear increase in efficiency of the
 FFT.
 That is to say we actually carry out 
\begin_inset Formula 
\[
\{L(x,y,t_{i})\mid i\in I_{j}\}=\big\{\mathcal{F}^{-1}\{\mathcal{F}\{G(x,y,t_{i})\}\cdot\mathcal{F}\{I(x,y)\}\}\mid i\in I_{j}\big\}
\]

\end_inset

where for 
\begin_inset Formula $j=1,\dots,m$
\end_inset

 the set 
\begin_inset Formula $I_{j}$
\end_inset

 indexes the scales allocated to a node 
\begin_inset Formula $j$
\end_inset

.
 In practice FFT execution time (both forward and inverse) is strongly dominated
 by I/O but this partitioning is still crucial in instances where our images
 are too large to fit in the RAM available on a single GPU (see section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:computers_eval"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
One remaining detail is histogram normalization of the images.
 Due to the dynamic range (i.e.
 variable bit depth) of the SEM we need to normalize the histogram of pixel
 values; we do this by saturating 
\begin_inset Formula $.175\%$
\end_inset

 of the darkest pixels, saturating 
\begin_inset Formula $.175\%$
\end_inset

 of the lightest pixels, and mapping the entire range to 
\begin_inset Formula $[0,1]$
\end_inset

.
 We find this gives us consistently robust results with respect to noise
 and anomalous features.
 This histogram normalization is also parallelized using GPU primitives.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Thus our algorithm takes the form
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% 
\backslash
begin{minted}[escapeinside=||,mathescape=true]{python}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% def create_embedded_kernel(sigma,height,width)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%     # create (0, sigma) 2d gaussian kernel
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%     # centered in array height x width
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% def get_local_maxima(dogs, sigma):
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% def detect_features(
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%     image, n_bins, min_sigma, max_sigma
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% ):
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%     img_h, img_w = image.shape
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%     |$
\backslash
delta t$| = (max_sigma - min_sigma)/n_bins
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%     sigmas = range(min_sigma, max_sigma+1, |$
\backslash
delta t$|)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%     kernels = [
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%         create_embedded_kernel(s, img_h, img_w)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%         for s in sigmas
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%     ]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%     filtered_imgs = |$
\backslash
mathcal{F}^{-1}
\backslash
{ 
\backslash
mathcal{F}
\backslash
{ 
\backslash
mathtt{image} 
\backslash
} * 
\backslash
mathcal{F}
\backslash
{ 
\backslash
mathtt{kernels} 
\backslash
}  
\backslash
}$| 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%     dog = (filtered_imgs[:-1] -    filtered_imgs[1:]) * sigmas
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% 
\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Evaluation
\begin_inset CommandInset label
LatexCommand label
name "sec:Evaluation"

\end_inset


\end_layout

\begin_layout Subsection
Science
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{subfigure}[b]
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

0.5
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textwidth
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset CommandInset include
LatexCommand input
filename "nbin_vs_gpu.lyx"

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Median runtime as a function of number of feature scales at resolution 
\begin_inset Formula $=1024\times1024$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:nbins"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{subfigure}[b]
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

0.5
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textwidth
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset CommandInset include
LatexCommand input
filename "res_vs_gpu.lyx"

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Median runtime as a function of section resolution with 16 feature scales.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:res"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Scaling experiments for runtime with respect to number of GPUs, resolution,
 and number of feature scales.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:evalplots"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Brains were prepared in the same manner and as previously described 
\begin_inset CommandInset citation
LatexCommand citet
literal "false"

\end_inset

.
 Briefly, an anesthetized animal was first transcardially perfused with
 10ml 0.1 M Sodium Cacodylate (cacodylate) buffer, pH 7.4 (Electron microscopy
 sciences (EMS) followed by 20 ml of fixative containing 2% paraformaldehyde
 (EMS), 2.5% glutaraldehyde (EMS) in 0.1 M Sodium Cacodylate (cacodylate)
 buffer, pH 7.4 (EMS).
 The brain was removed and placed in fixative for at least 24 hours at 4C.
 A series of 300 um vibratome sections were prepared and put into fixative
 for 24 hours at 4C.
 The primary visual cortex (V1) was identified using areal landmarks and
 reference atlases.
 A small piece (
\begin_inset space ~
\end_inset

2 x 2 mm) containing V1 was cut out and prepared for EM by staining sequentially
 with 2% osmium tetroxide (EMS) in cacodylate buffer, 2.5% potassium ferrocyanide
 (Sigma-Aldrich), thiocarbohydrazide, unbuffered 2% osmium tetroxide, 1%
 uranyl acetate, and 0.66% Aspartic acid buffered Lead (II) Nitrate with
 extensive rinses between each step with the exception of potassium ferrocyanide.
 The tissue was then dehydrated in ethanol and propylene oxide and infiltrated
 with 812 Epon resin (EMS, Mixture: 49% Embed 812, 28% DDSA, 21% NMA, and
 2.0% DMP 30).
 The resin-infiltrated tissue was cured at 60oC for 3 days.
 Using a commercial ultramicrotome (Powertome, RMC), the cured block was
 trimmed to a 
\begin_inset space ~
\end_inset

1.0mm x 1.5 mm rectangle and 
\begin_inset space ~
\end_inset

2,000, 40nm thick sections were collected on polyimide tape (Kapton) using
 an automated tape collecting device (ATUM, RMC) and assembled on silicon
 wafers as previously described (ref??).
 Images at different focal distances were acquired using backscattered electron
 detection with a Gemini 300 scanning electron microscope (Carl Zeiss),
 equipped with ATLAS software for automated imaging.
 Dwell times for all datasets were 1.0 microsecond.
\end_layout

\begin_layout Subsection
Computers
\begin_inset CommandInset label
LatexCommand label
name "subsec:computers_eval"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Test platform
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace -2ex
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="top">
<column alignment="none" valignment="top" width="15line%">
<column alignment="none" valignment="top" width="75line%">
<row>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPU 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dual AMD Rome 7742 @ 2.25GHz 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPU 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8x NVIDIA A100-40GB 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HD 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4x 3.84 U.2 NVMe SSD 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RAM 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1TB 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Software 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CuPy-8.3.0, CUDA-11.0, NVIDIA-450.51.05 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:test"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We perform runtime experiments across a range of parameters of interest
 (section resolution, number of feature scales).
 Our test platform is a NVIDIA DGX A100 (see table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:test"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Experiments consist of computing the DOF of a sample section for a given
 configuration.
 All experiments are repeated 
\begin_inset Formula $k$
\end_inset

 times (with 
\begin_inset Formula $k=21$
\end_inset

) and all metrics reported are in fact median statistics
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We discard the first execution since it is an outlier due to various initializat
ions (e.g.
 pinning CUDA memory).
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For a section resolution of 
\begin_inset Formula $1024\times1024$
\end_inset

 pixels we achieve approximately a 50Hz runtime in the single GPU configuration;
 this is XXXX faster than real time.
 We observe that, as expected, runtime grows linearly with the number of
 feature scales and quadratically with the resolution of the section; naturally,
 this is owing to the parallel architecture of the GPU.
 The principle defect of our technique is that it is highly dependent on
 the available RAM of the GPU it is deployed to.
 In practice, most GPUs available at the edge, i.e.
 proximal to microscopy instruments, will have insufficient ram to accommodate
 large section resolutions and wide feature scale ranges.
 In fact, even the 40GB of the DGX's A100 is exhausted at resolutions above
 
\begin_inset Formula $4096\times4096$
\end_inset

 for more than approximately 20 feature scales.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset

 
\begin_inset CommandInset include
LatexCommand input
preview true
filename "stacked_runtime.lyx"

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Breakdown of runtime into the four major phases for two GPUs across feature
 scales at resolution 
\begin_inset Formula $=1024\times1024$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:stacked"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Therefore, we further investigate parallelizing MHFD across multiple GPUs.
 Our implementation parallelizes MHFD in a straightforward fashion: we partition
 the set of filters across the GPUs, perform the 
\begin_inset Quotes eld
\end_inset

lighter
\begin_inset Quotes erd
\end_inset

 FFT-IFFT pair on each constituent GPU, and then gather the results to the
 root GPU (arbitrarily chosen).
 Note that for such multi-GPU configurations the range of feature scales
 was chosen to be a multiple of the number of GPUs (hence the proportionally
 increasing sparsity of data in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:nbins"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 We observe that, as one would expect, runtime is inversely proportional
 to number of GPUs (see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:res"
plural "false"
caps "false"
noprefix "false"

\end_inset

) but that for instances where a single GPU configuration is sufficient
 it is also optimal.
 More precise timing reveals that parallelization across multiple GPUs incurs
 high copy costs during the gather phase of parallel MHFD (see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:stacked"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Note that this latency persists even after taking advantage of CUDA IPC
 
\begin_inset CommandInset citation
LatexCommand citet
key "6270863"
literal "false"

\end_inset

.
 In effect, this is a fairly obvious demonstration of Amdahl's law.
 Therefore, we emphasize that parallelization across multiple GPUs should
 only be considered in instances where full resolution section images are
 of the utmost necessity
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
For example, when feature scale range are very wide, with detection at the
 lower end of the scale being critical.
 In all other cases downsampling by bilinear interpolation in order to satisfy
 GPU RAM constraints yields a more than reasonable tradeoff between accuracy
 and latency.
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:related"

\end_inset

 
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:conclusion"

\end_inset


\end_layout

\begin_layout Acknowledgments
This work was supported by the U.S.
 Department of Energy, Office of Science, under contract DE-AC02-06CH11357.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% 
\backslash
ryan{Marius LDRD}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "biblio"
options "ACM-Reference-Format"

\end_inset


\end_layout

\end_body
\end_document
